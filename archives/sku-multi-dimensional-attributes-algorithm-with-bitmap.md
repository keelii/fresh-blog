+++
title = "使用 bitmap 位运算解决 sku 多维路径组合问题"
isCJKLanguage = true
date = "2018-04-24T19:20:04-07:00"
draft = true
categories = ["jd", "algorithm"]
tags = ["javascript", "bitmap", "sku"]
+++

## 回顾问题

这是 [sku 多维属性状态判断算法](/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/) 的姊妹篇，上篇文章中主要运用了集合的幂集算法来解决 sku 属性组合时是否可选的问题，但是这个算法过于暴力，算法复杂度也特别高。不适合大量使用，尤其是在客户端单线程的 JavaScript 环境中，这种方法可以说是最低效的一种

那么有没有更好的方法呢？我们来重新回顾下问题。

首先，我们有一张如下的 sku 属性表：

| skuId | 颜色 | 尺码 | 型号 | attr N |
| ---- | ---- | ---- | ---- | ---- |
| 3158054 | 红   | 大   | A    | ... |
| 3133859 | 白   | 中   | B    | ... |
| 3516833 | 蓝   | 小   | C    | ... |
| 4516831 | 白 | 大 | B | ... |
| ... | ... | ... | ... | ... |


按属性分组后，默认会有一个选中的 sku (**3158054**)

![](https://img13.360buyimg.com/devfe/jfs/t3100/104/4921509103/3867/ea2bdd9b/585b9636Nc5d3efd4.png)

接下来需要遍历所有非选中属性，依次检测他们是否可选。逻辑如上篇所述。如果要确认「白」属性是否可选，上篇文章的做法可以简描述为：

> 「**白-大-A**」是否在于 3133859 这个 sku 的所有属性子集中（「白」、「白-中」、「白-B」、「中-B」、「白-中-B」）

所以本质上讲主要是因为 3133859 这个 sku 的所有属性子集都可以确定一个 sku 存在，如果 「**白-大-A**」不包含于这些子组合的子集，那么就反向证明了「**白-大-A**」不存在

## 逆向思考

上面的做法都是围绕着 **属性与值** 的对应关系做文章，我们能不能从 sku 的角度去摸索一下 **sku与值** 的关系呢

我们先分别列出来属性值「白、大、A」与 sku 的关系表

*颜色表*

| 颜色 | skuId           | Bitmap |
| ---- | --------------- | ----- |
| 白   | 3133859,4516831 | 0,1,0,1 |
| ...  | ...             | ... |

*尺码表*

| 尺码 | skuId   | Bitmap |
| ---- | ------- | ----- |
| 大   | 4516831 | 1,0,0,1 |
| ...  | ...     | ... |

*型号表*

| 型号 | skuId   | Bitmap |
| ---- | ------- | ----- |
| A    | 3158054 | 1,0,0,0 |
| ...  | ...     | ... |

为了看着简单表格里面只保留了「白、大、A」，这时候如何确定「白、大、A」是否存在

应该不难看出假如有个 sku 在这三张表中都存在，那就说明「白、大、A」存在，举例说明：

**不存在✘**

- 白-3133859,4516831
- 大-4516831
- A-3158054

**存在(3158054)✔**

- 红-**3158054**,3158054
- 大-**3158054**,4516831
- A-**3158054**

## 改进方法

难道我们去遍历三张表，查找是否每张表都至少含有同一个 sku 来确定存在与否吗？当然不是，仔细观察下这种运算方式，有一点像位运算吧，我们把 skuId 列改成长度为所有sku个数的 bitmap, 属性值存在为1不存在为0：

*颜色表*

| 颜色 | bitmap           |
| ---- | --------------- |
| 白   | 0,1,0,1 |
| 红 | 1,0,0,0 |

*尺码表*

| 尺码 | bitmap   |
| ---- | ------- |
| 大   | 1,0,0,1 |

*型号表*

| 型号 | bitmap   |
| ---- | ------- |
| A    | 1,0,0,0 |

这样的话确定「白-大-A」存在的方法就是把三个对应 bitmap 按位做与运算，结果大于0就说明存在，否则不存在

```js
// 白-大-A => false
(parseInt('0101', 2) & parseInt('1001', 2) & parseInt('1000', 2)) > 0
// 红-大-A => true
(parseInt('1000', 2) & parseInt('1001', 2) & parseInt('1000', 2)) > 0
```

既然思路有了代码就好写了，下面是我用 JavaScript 来实现的。需要说明的是客户端 JavaScript 本身没有办法存储原生二进制的数据，所以这个实现里面用数组来模拟，当然你可以使用 Node.js 里面的 ArrayBuffer 来存储 bitmap

<p data-height="265" data-theme-id="0" data-slug-hash="ELxmLR" data-default-tab="js,result" data-user="keelii" data-embed-version="2" data-pen-title="ELxmLR" class="codepen">See the Pen <a href="https://codepen.io/keelii/pen/ELxmLR/">ELxmLR</a> by kily zhou (<a href="https://codepen.io/keelii">@keelii</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

